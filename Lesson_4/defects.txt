1. Для функции 
def contains(self, string: str, symbol: str) -> bool:
        res = False
        try:
            res = string.index(symbol) > -1
        except ValueError:
            pass

        return res
        """
        Возвращает `True`, если строка содержит искомый символ
        и `False` - если нет \n
        Параметры: \n
            `string` - строка для обработки \n
            `symbol` - искомый символ \n
        Пример 1: `contains("SkyPro", "S") -> True`
        Пример 2: `contains("SkyPro", "U") -> False`
        """

успешно проходят негативные тесты со следующими данными:
("Microsoft", "MMM"),
("Microsoft", "mmm"),
("slug-is-human-readable", "---"),
("slug-is-human-readable", "___"),
("Текст с пробелами и датой 23.07.1645", "Текст"),
("Текст с пробелами и датой 23.07.1645", "Тест"),
("56789", "56789"),
("56789", "56_89"),
("!@#$%^&*()_+", "@#$"),
("!@#$%^&*()_+", "@ $")

Ожидаемый результат: тесты со всеми указанными данными выдают ошибку (FAILURE), т.к. по описанию и примерам второй параметр - единичный символ,
и строка из нескольких символов в качестве второго параметра должна быть невалидна.

Фактический результат: тесты с указанными данными работают (XPASS).

Вывод: функция ищет в строке для обработки не отдельный символ, а другую строку, состоящую из соответствующей последовательности символов.


2. Для функции 
def delete_symbol(self, string: str, symbol: str) -> str:
        if (self.contains(string, symbol)):
            string = string.replace(symbol, "")
        return string
        """
        Удаляет все подстроки из переданной строки \n
        Параметры: \n
            `string` - строка для обработки \n
            `symbol` - искомый символ для удаления \n
        Пример 1: `delete_symbol("SkyPro", "k") -> "SyPro"`
        Пример 2: `delete_symbol("SkyPro", "Pro") -> "Sky"`
        """

успешно проходят тесты как с отдельными символами, так и с подстроками.
Дефект в неточности описания.


3. Для функции 
def starts_with(self, string: str, symbol: str) -> bool:
        return string.startswith(symbol)
        """
        Возвращает `True`, если строка начинается с заданного символа
        и `False` - если нет \n
        Параметры: \n
            `string` - строка для обработки \n
            `symbol` - искомый символ \n
        Пример 1: `starts_with("SkyPro", "S") -> True`
        Пример 2: `starts_with("SkyPro", "P") -> False`
        """

успешно проходят негативные тесты со следующими данными:
("Microsoft", "Micro"),
("Microsoft", "mmm"),
("текст с пробелами и датой 23.07.1645", "текст"),
("текст с пробелами и датой 23.07.1645", "23.07.1645"),
("56789", "56789"),
("56789", "98765"),
("1", "231")
и т.п.

Ожидаемый результат: тесты со всеми указанными данными выдают ошибку (FAILURE), т.к. по описанию и примерам второй параметр - единичный символ,
и строка из нескольких символов в качестве второго параметра должна быть невалидна.

Фактический результат: тесты с указанными данными работают (XPASS).

Негативные тесты, в которых `symbol` является (под)строкой, начинающейся с такого же символа, как в строке для обработки, 
а остальные символы другие, падают, например:
("56789", "54321"),
("!@#$%^&*()_+", "! ! !")
и т.п.

Вывод: функция ищет в строке для обработки не отдельный символ, а другую строку, состоящую из соответствующей последовательности символов.


4. Для функции 
def ends_with(self, string: str, symbol: str) -> bool:
        return string.endswith(symbol)
        """
        Возвращает `True`, если строка заканчивается заданным символом
        и `False` - если нет \n
        Параметры: \n
            `string` - строка для обработки \n
            `symbol` - искомый символ \n
        Пример 1: `end_with("SkyPro", "o") -> True`
        Пример 2: `end_with("SkyPro", "y") -> False`
        """

успешно проходят негативные тесты со следующими данными:
("Microsoft", "soft"),
("Microsoft", "Micro"),
("-56789", "-56789"),
("56789", "98765"),
("slug-is-human-readable", "---"),
("1", "132")
и т.п.

Ожидаемый результат: тесты со всеми указанными данными выдают ошибку (FAILURE), т.к. по описанию и примерам второй параметр - единичный символ,
и строка из нескольких символов в качестве второго параметра должна быть невалидна.

Фактический результат: тесты с указанными данными работают (XPASS).

Негативные тесты, в которых `symbol` является (под)строкой, заканчивающейся таким же символом, как в строке для обработки, 
а остальные символы другие, падают, например:

("slug-is-human-readable", "eee"),
("!@#$%^&*()_+", "___+++"),
("1", "231")
и т.п.

Вывод: функция ищет в строке для обработки не отдельный символ, а другую строку, состоящую из соответствующей последовательности символов.



